% Geostrophic categories
% "ke_g", "pe_g", "te_mda"
% "te_g", "te_mda"
% "te_gmda"
%
% Wave categories
% "te_igw", "te_io"
% "te_wave"
%
% Each force can have,
% nonlinear flux
% quadratic nonlinear flux
% component-wise fluxes (depends on reservoir definitions)

%% input
% runName = "/Users/jearly/Documents/ProjectRepositories/CimRuns_May2025/output/run8_icR_iner1_tide1_psi0_geo1_res256";
% runName = "output/run4_icR_iner07_tide014_lat27_geo005_N0052_hydrostatic_res256";
runName = "/Users/jearly/Documents/ProjectRepositories/garrett-munk-spin-up/CimRuns_June2025/output/run1_icR_iner0_tide0_lat32_geo0065_N0052_hydrostatic_res256";
runName = "/Users/jearly/Documents/ProjectRepositories/garrett-munk-spin-up/CimRuns_June2025/output/run9_icR_iner07_tide014_lat32_geo0065_N0052_hydrostatic_res256";
% runName = "/Users/jearly/Documents/ProjectRepositories/CimRuns_May2025/output/run8_icR_iner1_tide1_psi0_geo1_res256";
filename = runName + ".nc";
% diagfilename = runName + "-diagnostics-high-stride-10.nc";
diagfilename = runName + "-diagnostics.nc";
reportFileOut = "figures/runNumber4/run4_CreateEnergyFluxReport.txt";
% model.createNetCDFFileForModelOutput("/Users/jearly/Documents/ProjectRepositories/garrett-munk-spin-up/CimRuns_June2025/output/run9_icR_iner07_tide014_lat32_geo0065_N0052_hydrostatic_res256-hf.nc",outputInterval=

%% load data
[wvt, ncfile] = WVTransform.waveVortexTransformFromFile(filename,iTime=Inf);
diagfile = NetCDFFile(diagfilename);
t = diagfile.readVariables('t');

timeAvgInd = round(.75*length(t)):1:length(t);

reservoirNames = ["te_gmda", "te_wave"];
filter1D = @(v) mean(v(timeAvgInd));
ddt_avg = @(v) diff(v(timeAvgInd([end,1]))) / diff(t(timeAvgInd([end,1])));

%% Measure total energy in each reservoir
[E_g,KE_g,PE_g,E_mda,E_w,E_io,ke,pe_quadratic,ape] = diagfile.readVariables('E_g','KE_g','PE_g','E_mda','E_w','E_io','ke','pe_quadratic','ape');

energy_total_quadratic = ke + pe_quadratic;
energy_total = ke + ape;
% we have to preallocated an array of structs
clear reservoirs;
reservoirs(length(reservoirNames)) = struct("name","placeholder");
for iReservoir = length(reservoirNames):-1:1
    reservoirs(iReservoir).name = reservoirNames(iReservoir);
    switch reservoirNames(iReservoir)
        case "ke_g"
            reservoirs(iReservoir).energy = filter1D(KE_g);
            reservoirs(iReservoir).ddt = ddt_avg(KE_g);
        case "pe_g"
            reservoirs(iReservoir).energy = filter1D(PE_g);
            reservoirs(iReservoir).ddt = ddt_avg(PE_g);
        case "te_g"
            reservoirs(iReservoir).energy = filter1D(KE_g + PE_g);
            reservoirs(iReservoir).ddt = ddt_avg(KE_g + PE_g);
        case "te_mda"
            reservoirs(iReservoir).energy = filter1D(E_mda);
            reservoirs(iReservoir).ddt = ddt_avg(E_mda);
        case "te_gmda"
            reservoirs(iReservoir).energy = filter1D(KE_g + PE_g + E_mda);
            reservoirs(iReservoir).ddt = ddt_avg(KE_g + PE_g + E_mda);
        case "te_igw"
            reservoirs(iReservoir).energy = filter1D(E_w);
            reservoirs(iReservoir).ddt = ddt_avg(E_w);
        case "te_io"
            reservoirs(iReservoir).energy = filter1D(E_io);
            reservoirs(iReservoir).ddt = ddt_avg(E_io);
        case "te_wave"
            reservoirs(iReservoir).energy = filter1D(E_w+E_io);
            reservoirs(iReservoir).ddt = ddt_avg(E_w+E_io);
        otherwise
            error("unknown energy reservoir");
    end
end


%% Measure total forcing flux to each reservoir (as table)
filter3D = @(v) sum(sum(mean(v(:,:,timeAvgInd),3),1),2);

% forcings
forcingNames = wvt.forcingNames;

% setup table
clear forcing_fluxes;
varNames = {reservoirNames{:},'total_for_forcing_quadratic','total_for_forcing_exact'};
sz = [length(forcingNames),length(varNames)];
varTypes = repmat("double", 1, length(varNames));
forcing_fluxes = table('Size',sz,'VariableNames',varNames,'VariableTypes',varTypes);

% build table
for iForce=1:length(forcingNames)
    name = replace(forcingNames(iForce),"-","_");
    name = replace(name," ","_");

    % these are temporary variavbles for use within this loop only
    Ejk.Ep = diagfile.readVariables("Ep_" + name);
    Ejk.Em = diagfile.readVariables("Em_" + name);
    Ejk.KE0 = diagfile.readVariables("KE0_" + name);
    Ejk.PE0 = diagfile.readVariables("PE0_" + name);

    % total fluxes
    forcing_fluxes.Properties.RowNames(iForce) = name;
    forcing_fluxes.total_for_forcing_exact(iForce) = filter1D(diagfile.readVariables("E_" + name));
    forcing_fluxes.total_for_forcing_quadratic(iForce) = filter3D(Ejk.Ep+Ejk.Em+Ejk.KE0+Ejk.PE0);

    % per-reservoir fluxes
    fluxes = EnergyFluxForReservoir(Ejk,reservoirNames);
    for iReservoir = 1:length(reservoirNames)
        forcing_fluxes.(reservoirNames(iReservoir))(iForce) = filter3D(fluxes{iReservoir});
    end
end
% sum columns
forcing_fluxes(end+1,:) = sum(forcing_fluxes,1);
forcing_fluxes.Properties.RowNames(end) = "total for reservoir";


%% Measure total inertial flux to each reservoir (as table)
filter3D = @(v) sum(sum(mean(v(:,:,timeAvgInd),3),1),2);

% triads
triadFlowComponents_t = [wvt.flowComponentWithName('wave'); wvt.flowComponentWithName('inertial'); wvt.flowComponentWithName('geostrophic');  wvt.flowComponentWithName('mda')];

% setup table
clear inertial_fluxes;
varNames = {reservoirNames{:},'total_for_triad_quadratic'};
sz = [length(triadFlowComponents_t)^2,length(varNames)];
varTypes = repmat("double", 1, length(varNames));
inertial_fluxes = table('Size',sz,'VariableNames',varNames,'VariableTypes',varTypes);

% build table
counter = 1;
for i=1:length(triadFlowComponents_t)
    for j=1:length(triadFlowComponents_t)
        name = triadFlowComponents_t(i).abbreviatedName + "_" + triadFlowComponents_t(j).abbreviatedName;

        % these are temporary variavbles for use within this loop only
        Ejk.Ep = diagfile.readVariables("Ep_" + name);
        Ejk.Em = diagfile.readVariables("Em_" + name);
        Ejk.KE0 = diagfile.readVariables("KE0_" + name);
        Ejk.PE0 = diagfile.readVariables("PE0_" + name);
    
        % total fluxes
        inertial_fluxes.Properties.RowNames(counter) = name;
        inertial_fluxes.total_for_triad_quadratic(counter) = filter3D(Ejk.Ep+Ejk.Em+Ejk.KE0+Ejk.PE0);
    
        % per-reservoir fluxes
        fluxes = EnergyFluxForReservoir(Ejk,reservoirNames);
        for iReservoir = 1:length(reservoirNames)
            inertial_fluxes.(reservoirNames(iReservoir))(counter) = filter3D(fluxes{iReservoir});
        end

        % increment counter
        counter = counter+1;
    end
end
% sum columns
% inertial_fluxes(end+1,:) = ['total for reservoir',table2cell(sum(inertial_fluxes(:,2:end),1))];
inertial_fluxes(end+1,:) = sum(inertial_fluxes,1);
inertial_fluxes.Properties.RowNames(end) = "total for reservoir";

% %% Measure total forcing flux to each reservoir (as struct)
% filter3D = @(v) sum(sum(mean(v(:,:,timeAvgInd),3),1),2);
% 
% forcingNames = wvt.forcingNames;
% if diagfile.hasVariableWithName("E_antialias_filter")
%     forcingNames(end+1) = "antialias filter";
% end
% clear forcing_fluxes;
% forcing_fluxes(length(forcingNames)) = struct("name","placeholder");
% for iForce=1:length(forcingNames)
%     name = replace(forcingNames(iForce),"-","_");
%     name = replace(name," ","_");
% 
%     forcing_fluxes(iForce).name = forcingNames(iForce);
%     forcing_fluxes(iForce).flux_total = filter1D(diagfile.readVariables("E_" + name));
% 
%     % these are temporary variavbles for use within this loop only
%     Ejk.Ep = diagfile.readVariables("Ep_" + name);
%     Ejk.Em = diagfile.readVariables("Em_" + name);
%     Ejk.KE0 = diagfile.readVariables("KE0_" + name);
%     Ejk.PE0 = diagfile.readVariables("PE0_" + name);
%     forcing_fluxes(iForce).flux_total_quadratic = filter3D(Ejk.Ep+Ejk.Em+Ejk.KE0+Ejk.PE0);
% 
%     fluxes = EnergyFluxForReservoir(Ejk,reservoirNames);
%     for iReservoir = 1:length(reservoirNames)
%         forcing_fluxes(iForce).(reservoirNames(iReservoir)) = filter3D(fluxes{iReservoir});
%     end
% end

% %% Measure total inertial flux between each reservoir (as struct)
% clear inertial_fluxes;
% inertial_fluxes(length(reservoirNames)) = struct("name","placeholder");
% triadFlowComponents_t = [wvt.flowComponentWithName('wave'); wvt.flowComponentWithName('inertial'); wvt.flowComponentWithName('geostrophic');  wvt.flowComponentWithName('mda')];
% 
% for iReservoir = length(reservoirNames):-1:1
%     inertial_fluxes(iReservoir).name = reservoirNames(iReservoir);
%     inertial_fluxes(iReservoir).total_flux = 0;
%     for i=1:length(triadFlowComponents_t)
%         for j=1:length(triadFlowComponents_t)
%             name = triadFlowComponents_t(i).abbreviatedName + "_" + triadFlowComponents_t(j).abbreviatedName;
% 
%             Ejk.Ep = diagfile.readVariables("Ep_" + name);
%             Ejk.Em = diagfile.readVariables("Em_" + name);
%             Ejk.KE0 = diagfile.readVariables("KE0_" + name);
%             Ejk.PE0 = diagfile.readVariables("PE0_" + name);
% 
%             fluxes = EnergyFluxForReservoir(Ejk,reservoirNames);
%             inertial_fluxes(iReservoir).(name) = filter3D(fluxes{iReservoir});
%             inertial_fluxes(iReservoir).total_flux = inertial_fluxes(iReservoir).(name) + inertial_fluxes(iReservoir).total_flux;
%         end
%     end
% end

%%
function eFlux = EnergyFluxForReservoir(Ejk,reservoirNames)
eFlux = cell(length(reservoirNames),1);
for iReservoir = 1:length(reservoirNames)
    switch reservoirNames(iReservoir)
        case "ke_g"
            eFlux{iReservoir} = Ejk.KE0(:,2:end,:);
        case "pe_g"
            eFlux{iReservoir} = Ejk.PE0(:,2:end,:);
        case "te_g"
            eFlux{iReservoir} = Ejk.KE0(:,2:end,:)+Ejk.PE0(:,2:end,:);
        case "te_mda"
            eFlux{iReservoir} = Ejk.PE0(:,1,:);
        case "te_gmda"
            eFlux{iReservoir} = Ejk.KE0 + Ejk.PE0;
        case "te_igw"
            eFlux{iReservoir} = Ejk.Ep(:,2:end,:) + Ejk.Em(:,2:end,:);
        case "te_io"
            eFlux{iReservoir} = Ejk.Ep(:,1,:) + Ejk.Em(:,1,:);
        case "te_wave"
            eFlux{iReservoir} = Ejk.Ep+Ejk.Em;
        otherwise
            error("unknown energy reservoir");
    end
end
end

return
%% generate text report

% unit conversions
E_gm = 3.74;
flux_conversion = 86400*365/E_gm;
flux_units = "GM/yr";

% start report file
fileID = fopen(reportFileOut,"w");
fprintf(fileID,"\nEnergy reservoir and flux report for %s. \n",filename);
fprintf(fileID,"Average over days %d to %d. \n",t(timeAvgInd(1))/86400,t(timeAvgInd(end))/86400);
fprintf(fileID,"Generated %s \n \n",datetime);

% forcing fluxes, SI units
fprintf(fileID,"\nForcing Fluxes (m^3 s^-3)\n");
str = formattedDisplayText(forcing_fluxes,'NumericFormat','short');
str = erase(str,"<strong>");
str = erase(str,"</strong>");
fprintf(fileID,"%s",str);
fprintf(fileID,"\n\n");

% inertial fluxes, SI units
fprintf(fileID,"\nInertial Fluxes (m^3 s^-3)\n");
str = formattedDisplayText(inertial_fluxes,'NumericFormat','short');
str = erase(str,"<strong>");
str = erase(str,"</strong>");
fprintf(fileID,"%s",str);
fprintf(fileID,"\n\n");

% forcing fluxes, GM units
fprintf(fileID,"\nForcing Fluxes (GM/yr)\n");
str = formattedDisplayText(forcing_fluxes.*flux_conversion,'NumericFormat','bank');
str = erase(str,"<strong>");
str = erase(str,"</strong>");
fprintf(fileID,"%s",str);
fprintf(fileID,"\n\n");

% inertial fluxes, GM units
fprintf(fileID,"\nInertial Fluxes (GM/yr)\n");
str = formattedDisplayText(inertial_fluxes.*flux_conversion,'NumericFormat','bank');
str = erase(str,"<strong>");
str = erase(str,"</strong>");
fprintf(fileID,"%s",str);
fprintf(fileID,"\n\n");


%% generate box plot
% return figure handle so it can be modified and saved outside function.





% %% net flux should be zero
% 
% % sum of all forcing fluxes, including nonlinear advection, should equal
% % rate of change for each reservoir
% for iReservoir = 1:length(reservoirNames)    
%     a = reservoirs(iReservoir).ddt*flux_conversion
%     b = ([forcing_fluxes.(reservoirNames(iReservoir))]).*flux_conversion
%     c = inertial_fluxes(iReservoir).total_flux*flux_conversion
%     sum(b)-a
% end
% 
% % total energy rate of change should equal flux_total
% reservoirs(1).ddt+reservoirs(2).ddt
% sum([forcing_fluxes.flux_total])
% 
% % forcing_fluxes(1) should equal inertial_fluxes.total_flux for each
% % reservoir
% for iReservoir = 1:length(reservoirNames)    
%     a = forcing_fluxes(1).(reservoirNames(iReservoir)).*flux_conversion
%     b = inertial_fluxes(iReservoir).total_flux*flux_conversion
%     b-a
% end
% 
% %% Looking at sub-sets of total_flux
% 
% allTOgmda = inertial_fluxes(1).w_w...
%     +inertial_fluxes(1).w_io...
%     +inertial_fluxes(1).w_g...
%     +inertial_fluxes(1).w_mda...
%     +inertial_fluxes(1).io_w...
%     +inertial_fluxes(1).io_io...
%     +inertial_fluxes(1).io_g...
%     +inertial_fluxes(1).io_mda...
%     +inertial_fluxes(1).g_w...
%     +inertial_fluxes(1).g_io...
%     +inertial_fluxes(1).g_g...
%     +inertial_fluxes(1).g_mda...
%     +inertial_fluxes(1).mda_w...
%     +inertial_fluxes(1).mda_io...
%     +inertial_fluxes(1).mda_g...
%     +inertial_fluxes(1).mda_mda...
% 
% anywaveTOgmda = inertial_fluxes(1).w_w...
%     +inertial_fluxes(1).w_io...
%     +inertial_fluxes(1).w_g...
%     +inertial_fluxes(1).w_mda...
%     +inertial_fluxes(1).io_w...
%     +inertial_fluxes(1).io_io...
%     +inertial_fluxes(1).io_g...
%     +inertial_fluxes(1).io_mda...
%     +inertial_fluxes(1).g_w...
%     +inertial_fluxes(1).g_io...
%     ...+inertial_fluxes(1).g_g...
%     ...+inertial_fluxes(1).g_mda...
%     +inertial_fluxes(1).mda_w...
%     +inertial_fluxes(1).mda_io...
%     ...+inertial_fluxes(1).mda_g...
%     ...+inertial_fluxes(1).mda_mda...
% 
% waveinteractionTOgmda = ...inertial_fluxes(1).w_w...
%     ...+inertial_fluxes(1).w_io...
%     +inertial_fluxes(1).w_g...
%     +inertial_fluxes(1).w_mda...
%     ...+inertial_fluxes(1).io_w...
%     ...+inertial_fluxes(1).io_io...
%     +inertial_fluxes(1).io_g...
%     +inertial_fluxes(1).io_mda...
%     +inertial_fluxes(1).g_w...
%     +inertial_fluxes(1).g_io...
%     ...+inertial_fluxes(1).g_g...
%     ...+inertial_fluxes(1).g_mda...
%     +inertial_fluxes(1).mda_w...
%     +inertial_fluxes(1).mda_io...
%     ...+inertial_fluxes(1).mda_g...
%     ...+inertial_fluxes(1).mda_mda...
% 
% purewaveTOgmda = inertial_fluxes(1).w_w...
%     +inertial_fluxes(1).w_io...
%     ...+inertial_fluxes(1).w_g...
%     ...+inertial_fluxes(1).w_mda...
%     +inertial_fluxes(1).io_w...
%     +inertial_fluxes(1).io_io...
%     ...+inertial_fluxes(1).io_g...
%     ...+inertial_fluxes(1).io_mda...
%     ...+inertial_fluxes(1).g_w...
%     ...+inertial_fluxes(1).g_io...
%     ...+inertial_fluxes(1).g_g...
%     ...+inertial_fluxes(1).g_mda...
%     ...+inertial_fluxes(1).mda_w...
%     ...+inertial_fluxes(1).mda_io...
%     ...+inertial_fluxes(1).mda_g...
%     ...+inertial_fluxes(1).mda_mda...
% 
% gmdaTOgmda = ...inertial_fluxes(1).w_w...
%     ...+inertial_fluxes(1).w_io...
%     ...+inertial_fluxes(1).w_g...
%     ...+inertial_fluxes(1).w_mda...
%     ...+inertial_fluxes(1).io_w...
%     ...+inertial_fluxes(1).io_io...
%     ...+inertial_fluxes(1).io_g...
%     ...+inertial_fluxes(1).io_mda...
%     ...+inertial_fluxes(1).g_w...
%     ...+inertial_fluxes(1).g_io...
%     +inertial_fluxes(1).g_g...
%     +inertial_fluxes(1).g_mda...
%     ...+inertial_fluxes(1).mda_w...
%     ...+inertial_fluxes(1).mda_io...
%     +inertial_fluxes(1).mda_g...
%     +inertial_fluxes(1).mda_mda...
% 
% 
% 
% allTOwave = inertial_fluxes(2).w_w...
%     +inertial_fluxes(2).w_io...
%     +inertial_fluxes(2).w_g...
%     +inertial_fluxes(2).w_mda...
%     +inertial_fluxes(2).io_w...
%     +inertial_fluxes(2).io_io...
%     +inertial_fluxes(2).io_g...
%     +inertial_fluxes(2).io_mda...
%     +inertial_fluxes(2).g_w...
%     +inertial_fluxes(2).g_io...
%     +inertial_fluxes(2).g_g...
%     +inertial_fluxes(2).g_mda...
%     +inertial_fluxes(2).mda_w...
%     +inertial_fluxes(2).mda_io...
%     +inertial_fluxes(2).mda_g...
%     +inertial_fluxes(2).mda_mda...
% 
% anygmdaTOwave = ...inertial_fluxes(2).w_w...
%     ...+inertial_fluxes(2).w_io...
%     +inertial_fluxes(2).w_g...
%     +inertial_fluxes(2).w_mda...
%     ...+inertial_fluxes(2).io_w...
%     ...+inertial_fluxes(2).io_io...
%     +inertial_fluxes(2).io_g...
%     +inertial_fluxes(2).io_mda...
%     +inertial_fluxes(2).g_w...
%     +inertial_fluxes(2).g_io...
%     +inertial_fluxes(2).g_g...
%     +inertial_fluxes(2).g_mda...
%     +inertial_fluxes(2).mda_w...
%     +inertial_fluxes(2).mda_io...
%     +inertial_fluxes(2).mda_g...
%     +inertial_fluxes(2).mda_mda...
% 
% gmdainteractionTOwave = ...inertial_fluxes(2).w_w...
%     ...+inertial_fluxes(2).w_io...
%     +inertial_fluxes(2).w_g...
%     +inertial_fluxes(2).w_mda...
%     ...+inertial_fluxes(2).io_w...
%     ...+inertial_fluxes(2).io_io...
%     +inertial_fluxes(2).io_g...
%     +inertial_fluxes(2).io_mda...
%     +inertial_fluxes(2).g_w...
%     +inertial_fluxes(2).g_io...
%     ...+inertial_fluxes(2).g_g...
%     ...+inertial_fluxes(2).g_mda...
%     +inertial_fluxes(2).mda_w...
%     +inertial_fluxes(2).mda_io...
%     ...+inertial_fluxes(2).mda_g...
%     ...+inertial_fluxes(2).mda_mda...
% 
% puregmdaTOwave = ...inertial_fluxes(2).w_w...
%     ...+inertial_fluxes(2).w_io...
%     ...+inertial_fluxes(2).w_g...
%     ...+inertial_fluxes(2).w_mda...
%     ...+inertial_fluxes(2).io_w...
%     ...+inertial_fluxes(2).io_io...
%     ...+inertial_fluxes(2).io_g...
%     ...+inertial_fluxes(2).io_mda...
%     ...+inertial_fluxes(2).g_w...
%     ...+inertial_fluxes(2).g_io...
%     +inertial_fluxes(2).g_g...
%     +inertial_fluxes(2).g_mda...
%     ...+inertial_fluxes(2).mda_w...
%     ...+inertial_fluxes(2).mda_io...
%     +inertial_fluxes(2).mda_g...
%     +inertial_fluxes(2).mda_mda...
% 
% 
% waveTOwave = inertial_fluxes(2).w_w...
%     +inertial_fluxes(2).w_io...
%     ...+inertial_fluxes(2).w_g...
%     ...+inertial_fluxes(2).w_mda...
%     +inertial_fluxes(2).io_w...
%     +inertial_fluxes(2).io_io...
%     ...+inertial_fluxes(2).io_g...
%     ...+inertial_fluxes(2).io_mda...
%     ...+inertial_fluxes(2).g_w...
%     ...+inertial_fluxes(2).g_io...
%     ...+inertial_fluxes(2).g_g...
%     ...+inertial_fluxes(2).g_mda...
%     ...+inertial_fluxes(2).mda_w...
%     ...+inertial_fluxes(2).mda_io...
%     ...+inertial_fluxes(2).mda_g...
%     ...+inertial_fluxes(2).mda_mda...
% 
% 
% 
